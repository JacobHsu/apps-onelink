[
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "eb7c268c-f0e6-42aa-926b-5f59e94b92f3",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC001-Profile Management - Update Profile Information",
    "description": "Verify that users can update their profile information including name, description, and avatar image, and changes are reflected immediately in the live preview.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Input valid name and description in the profile section.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('This is a test description for the user profile.')\n        \n\n        # Upload a valid avatar image to the profile.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that the input fields accept the changes by verifying the filled values.\n        name_input = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        description_input = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        assert await name_input.input_value() == 'Test User', 'Name input value mismatch'\n        assert await description_input.input_value() == 'This is a test description for the user profile.', 'Description input value mismatch'\n        # Assert that the live preview updates immediately to reflect the new profile information.\n        # Assuming live preview elements have specific selectors to verify updated content\n        live_preview_name = frame.locator('xpath=html/body/div/div/div/div/div/div[3]/div/div/div/span').nth(0)\n        live_preview_description = frame.locator('xpath=html/body/div/div/div/div/div/div[3]/div/div/div/span').nth(1)\n        assert await live_preview_name.text_content() == 'Test User', 'Live preview name mismatch'\n        assert await live_preview_description.text_content() == 'This is a test description for the user profile.', 'Live preview description mismatch'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756094966077059//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.848Z",
    "modified": "2025-08-25T04:09:26.245Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "9324cb13-adcf-4113-8dd2-1cd1f49e6825",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC002-Profile Management - Empty and Special Character Inputs",
    "description": "Verify the system handles empty and special character inputs correctly for profile fields and updates the live preview accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Clear the name and description fields and remove the avatar image.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # Clear the description field and remove the avatar image.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # Locate and remove the avatar image if possible.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Input special characters and unicode emojis into the name and description fields.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('!@#$%^&*()_+-=[]{}|;:\\'\",.<>/?`~')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('üòÄüöÄ‚ú®üî•üíßüåüüéâüëçüèΩ‚ù§Ô∏è\\u200düî•')\n        \n\n        # Verify that the live preview correctly renders or sanitizes the special characters and emojis without errors.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Verify if the live preview updates dynamically or requires a save/refresh action. If needed, try to trigger a save or refresh to see if live preview updates with special characters and emojis.\n        await page.mouse.wheel(0, -window.innerHeight)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Test clearing the name and description fields again to verify validation messages and live preview update, then proceed to test avatar removal if possible.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # Attempt to locate any avatar image or removal control by scrolling or searching the page, or confirm if avatar removal is unsupported.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Assertion: Verify the system accepts empty fields or shows validation messages for name and description fields.\n        name_input = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        description_input = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        # Check if validation message appears for empty name field\n        name_validation = await frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input/following-sibling::div[contains(@class, \"validation-message\")]').count()\n        assert name_validation == 0 or name_validation > 0, 'Validation message for empty name field should be present or empty input accepted'\n        # Check if validation message appears for empty description field\n        description_validation = await frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input/following-sibling::div[contains(@class, \"validation-message\")]').count()\n        assert description_validation == 0 or description_validation > 0, 'Validation message for empty description field should be present or empty input accepted'\n        # Assertion: Confirm live preview updates with special characters and emojis without errors\n        live_preview_name = await frame.locator('xpath=html/body/div/div/div/div/div/div[3]/div/div[1]').inner_text()\n        live_preview_description = await frame.locator('xpath=html/body/div/div/div/div/div/div[3]/div/div[2]').inner_text()\n        assert '!@#$%^&*()_+-=[]{}|;:\\\"\\',.<>/?`~' in live_preview_name, 'Live preview should render special characters in name field'\n        assert 'üòÄüöÄ‚ú®üî•üíßüåüüéâüëçüèΩ‚ù§Ô∏è\\u200düî•' in live_preview_description, 'Live preview should render emojis in description field'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095106656746//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.856Z",
    "modified": "2025-08-25T04:11:46.823Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "665f1bb3-b0cc-4fb4-b394-55a34c864c06",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC003-Social Links Management - Add and Edit Multiple Platform Links",
    "description": "Verify users can add, edit, and configure social media links across different platforms, and changes reflect instantly in live preview.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to social links management section.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Edit existing social media URLs to new valid addresses and verify live preview updates instantly.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://twitter.com/newexample')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://claude.ai/new')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[3]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://linkedin.com/in/newexample')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[4]/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://notebooklm.google.com/new')\n        \n\n        # Verify that the live preview updates instantly and correctly for all edited social media links, then complete the task.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/main/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/main/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/main/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Return to the main testing tab and finalize the task as the live preview updates were confirmed on the main app page.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Assertion: Verify the links are accepted and displayed properly in the input fields.\n        frame = context.pages[-1]\n        twitter_input = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        claude_input = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/div/div/div/div[2]/input').nth(0)\n        linkedin_input = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[3]/div/div/div/div[2]/input').nth(0)\n        notebook_input = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[4]/div/div/div/div[2]/input').nth(0)\n        assert await twitter_input.input_value() == 'https://twitter.com/newexample', 'Twitter URL not updated correctly'\n        assert await claude_input.input_value() == 'https://claude.ai/new', 'Claude URL not updated correctly'\n        assert await linkedin_input.input_value() == 'https://linkedin.com/in/newexample', 'LinkedIn URL not updated correctly'\n        assert await notebook_input.input_value() == 'https://notebooklm.google.com/new', 'Notebook URL not updated correctly'\n        \n        # Assertion: Confirm live preview updates to reflect the updated social links instantly.\n        # Assuming live preview links have selectors to verify their href attributes\n        live_preview_twitter = frame.locator('xpath=//a[contains(@href, \"twitter.com/newexample\")]')\n        live_preview_claude = frame.locator('xpath=//a[contains(@href, \"claude.ai/new\")]')\n        live_preview_linkedin = frame.locator('xpath=//a[contains(@href, \"linkedin.com/in/newexample\")]')\n        live_preview_notebook = frame.locator('xpath=//a[contains(@href, \"notebooklm.google.com/new\")]')\n        assert await live_preview_twitter.count() > 0, 'Live preview Twitter link not updated'\n        assert await live_preview_claude.count() > 0, 'Live preview Claude link not updated'\n        assert await live_preview_linkedin.count() > 0, 'Live preview LinkedIn link not updated'\n        assert await live_preview_notebook.count() > 0, 'Live preview Notebook link not updated'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095070343034//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.864Z",
    "modified": "2025-08-25T04:11:10.556Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "b240bc3c-29e3-4156-97af-ba5378c6c067",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC004-Social Links Management - Invalid URL Input Handling",
    "description": "Verify that invalid or malformed social media URLs are detected and appropriate error messages are displayed without updating live preview.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Input invalid URLs (e.g., missing protocol, invalid domain) into the social media app link input fields starting with App 1.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-url')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('www.invalid-url')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('http//missing-colon.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://invalid_domain')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('htp://wrongprotocol.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('http://.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('http://invalid-url-.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[8]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('http://invalid..com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[9]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('http://invalid_url.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[10]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('http://invalid-url.com/space here')\n        \n\n        assert False, 'Test failed due to unknown expected result; this assertion is intentionally failing.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested invalid or malformed social media URLs input. No validation error messages were displayed for invalid URLs, which is a failure in validation detection. However, the live preview did not update with invalid URLs, which is correct behavior. Overall, the system fails to notify users of invalid URLs but prevents live preview update with invalid data. Further fix is needed for validation error display.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/17560949787592//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.870Z",
    "modified": "2025-08-25T04:09:38.992Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "45f095dc-1f79-437d-acc3-8649c8c28253",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC005-Custom Links Management - Add, Edit, Delete, and Reorder Links",
    "description": "Verify users can add new custom links, edit existing ones, delete links, and reorder them using drag-and-drop with live preview updating accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to custom links management panel by clicking the appropriate button or link.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Add multiple custom links with valid URLs and descriptive labels by filling inputs and clicking add buttons.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Example Link 1')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://example1.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Add a second custom link with valid label and URL.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Example Link 2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://example2.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Edit the label and URL of the existing custom link 'Example Link 2' to new values and save the changes.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Updated Link 2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://updatedexample2.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Delete the custom link 'Updated Link 2' from the list and verify it is removed from the list and live preview.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested adding, editing, and attempted deleting custom links. Deletion failed as the link remains after clicking delete. Reporting this as a critical issue and stopping further testing.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095083537162//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.876Z",
    "modified": "2025-08-25T04:11:23.730Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "02d2fa11-b0dc-420b-9352-25e9eed71e42",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC006-Custom Links Management - Handling Invalid Inputs",
    "description": "Verify form validation prevents adding or editing custom links with invalid URLs, empty labels, or missing fields.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Try to add a custom link with empty label and valid URL by clicking an 'Add' button to open the form.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the submit button to try to add the custom link with empty label and valid URL and check for validation error.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Fill the label field with a valid label and the URL field with an invalid URL format, then submit the form to check for URL format validation errors.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Valid Label')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-url-format')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Form validation for empty labels works correctly. However, URL format validation is missing or not enforced, allowing invalid URLs to be added without error. Reporting this issue and stopping further testing until fixed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756094975606361//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.882Z",
    "modified": "2025-08-25T04:09:35.760Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "a7040f78-d282-407d-8570-95ae1a0ed13d",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC007-Live Preview - Real-Time Update Accuracy",
    "description": "Verify that any change made to profile, social links, or custom links is instantly and accurately reflected in the live preview without delay or errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Input new text into the Name and Category fields to test live preview update.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Technology')\n        \n\n        # Add a social media link or edit an existing one and verify if the live preview updates accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://twitter.com/testuser')\n        \n\n        # Add a custom link or modify existing custom links and check if live preview updates instantly and accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input new custom link label and URL, then verify if live preview updates instantly and accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Custom Link')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://customlink.com/test')\n        \n\n        # Edit the custom link label and URL, then verify live preview updates instantly and accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Updated Custom Link')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://updatedcustomlink.com')\n        \n\n        # Delete the updated custom link and verify if the live preview removes it instantly and accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try deleting the custom link again or delete another link and verify if the live preview updates instantly and accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Edit a social media link and then delete it, verifying if live preview updates instantly and accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://editedsociallink.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to delete another custom link or social media link and verify if live preview updates instantly and accurately.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert live preview updates immediately and displays the new profile data correctly.\n        frame = context.pages[-1]\n        name_preview = await frame.locator('xpath=//div[contains(@class, \"live-preview\")]//span[contains(text(), \"Test User\")]').count()\n        assert name_preview > 0, \"Live preview does not show updated name 'Test User'\"\n        category_preview = await frame.locator('xpath=//div[contains(@class, \"live-preview\")]//span[contains(text(), \"Technology\")]').count()\n        assert category_preview > 0, \"Live preview does not show updated category 'Technology'\"\n        # Confirm live preview updates accurately to match social links changes.\n        social_link_preview = await frame.locator('xpath=//div[contains(@class, \"live-preview\")]//a[contains(@href, \"https://twitter.com/testuser\")]').count()\n        assert social_link_preview > 0, \"Live preview does not show updated social link 'https://twitter.com/testuser'\"\n        # Verify live preview reflects the custom links changes instantaneously without errors.\n        custom_link_label_preview = await frame.locator('xpath=//div[contains(@class, \"live-preview\")]//a[contains(text(), \"Updated Custom Link\")]').count()\n        assert custom_link_label_preview > 0, \"Live preview does not show updated custom link label 'Updated Custom Link'\"\n        custom_link_url_preview = await frame.locator('xpath=//div[contains(@class, \"live-preview\")]//a[contains(@href, \"https://updatedcustomlink.com\")]').count()\n        assert custom_link_url_preview > 0, \"Live preview does not show updated custom link URL 'https://updatedcustomlink.com'\"\n        # Verify the deleted custom link is removed from live preview.\n        deleted_custom_link_preview = await frame.locator('xpath=//div[contains(@class, \"live-preview\")]//a[contains(text(), \"Test Custom Link\")]').count()\n        assert deleted_custom_link_preview == 0, \"Live preview still shows deleted custom link 'Test Custom Link'\"\n        # Verify the deleted social media link is removed from live preview.\n        deleted_social_link_preview = await frame.locator('xpath=//div[contains(@class, \"live-preview\")]//a[contains(@href, \"https://editedsociallink.com\")]').count()\n        assert deleted_social_link_preview == 0, \"Live preview still shows deleted social link 'https://editedsociallink.com'\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095239253854//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.889Z",
    "modified": "2025-08-25T04:13:59.418Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "057ed4ea-1f50-478f-a69a-dbc2f3bb24e9",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC008-URL-based Data Storage - Encode and Preserve Data",
    "description": "Verify that all user data including profile information, social links, and custom links are correctly encoded into the URL, and reloaded properly after page refresh or URL sharing.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Fill profile fields 'Name' and 'Category' with valid data.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Technology')\n        \n\n        # Fill Apps Links fields (App 1 to App 12) with valid data.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink1')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink3')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink4')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink5')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink6')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink7')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[8]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink8')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[9]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink9')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[10]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink10')\n        \n\n        # Fill Apps Links fields App 11 and App 12 with valid data.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[11]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink11')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[12]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink12')\n        \n\n        # Trigger an action or event to update the URL with encoded data, or verify if the URL updates automatically after data entry.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Look for a button or control to generate or update the URL with encoded data, or try to reload the page to check if data persists.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Look for a button or control to generate or update the URL with encoded data, or try to reload the page to check if data persists.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Reload the page using the current URL to verify if all form fields and live preview are restored correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Refill profile and apps links fields with valid data to check if URL encoding happens after data entry or an action.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Technology')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink1')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink3')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink4')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink5')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink6')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink7')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[8]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AppLink8')\n        \n\n        # Click on other category buttons (Finance, News, Productivity, Health, Tools) to check if any trigger URL encoding or data serialization.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Reload the page using the current URL to verify if all form fields and live preview are restored correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        assert False, 'Test plan execution failed: expected result unknown, forcing failure.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify that all user data including profile information, social links, and custom links are correctly encoded into the URL and reloaded properly after page refresh or URL sharing is not fully successful. Despite filling all fields with valid data and clicking various buttons to trigger data serialization, the URL remained unchanged at the base 'http://localhost:3000/'. Reloading the page cleared all data, indicating no data persistence or encoding in the URL. Therefore, the application does not currently encode or restore user data via the URL as required by the task.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095335450752//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.895Z",
    "modified": "2025-08-25T04:15:35.612Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "feb10221-9e76-4ff2-83c9-54331193157d",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC009-URL-based Data Storage - Large Data Size and Edge Cases",
    "description": "Test the system's ability to handle large amounts of data encoded in the URL and edge cases such as special characters and maximum field lengths.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Input very large profile description and fill all app link fields with long URLs close to typical URL length limits.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"This is a very large profile description text designed to test the system's ability to handle maximum field lengths and special characters like !@#$%^&*()_+-=[]{}|;':,.<>/?`~ and unicode characters like Ê∏¨Ë©¶, —Ç–µ—Å—Ç, ÿßÿÆÿ™ÿ®ÿßÿ±, ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£, „ÉÜ„Çπ„Éà. This description is intentionally long to approach typical URL length limits for encoding.\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Category with special characters !@#$%^&*() and very long text to test encoding and length limits in URL generation.')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app1?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app2?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app3?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app4?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app5?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app6?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app7?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[8]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app8?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        # Trigger URL generation or save to check the URL encoding and length handling.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to find or trigger the full encoded URL generation or export function. Then reload the page using the long URL to verify data restoration.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/main/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate back to the original profile input page at localhost:3000 to continue testing URL encoding and data restoration.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Re-input the large profile description and app links with special characters and long URLs to test URL generation again.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"This is a very large profile description text designed to test the system's ability to handle maximum field lengths and special characters like !@#$%^&*()_+-=[]{}|;':,.<>/?`~ and unicode characters like Ê∏¨Ë©¶, —Ç–µ—Å—Ç, ÿßÿÆÿ™ÿ®ÿßÿ±, ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£, „ÉÜ„Çπ„Éà. This description is intentionally long to approach typical URL length limits for encoding.\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Category with special characters !@#$%^&*() and very long text to test encoding and length limits in URL generation.')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app1?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app2?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app3?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app4?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app5?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app6?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app7?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[8]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"https://example.com/app8?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{}|;':,.<>/?`~\")\n        \n\n        # Click 'Add AI data' button to trigger URL generation and then extract the full encoded URL.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Check the browser address bar for the full URL or look for a 'Share', 'Copy URL', or 'Export' button to obtain the full encoded URL. Then reload the page with that URL to verify data restoration.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert the URL contains the full encoded data without truncation or corruption\n        current_url = page.url\n        assert len(current_url) > 200, f\"URL length is unexpectedly short: {len(current_url)}\"\n        assert '%20' in current_url or '%21' in current_url or '%40' in current_url, \"URL encoding for special characters missing\"\n        # Reload the page with the current URL to verify data restoration\n        await page.goto(current_url)\n        # Verify the large profile description is restored correctly\n        frame = context.pages[-1]\n        profile_desc_elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        restored_profile_desc = await profile_desc_elem.input_value()\n        expected_profile_desc = \"This is a very large profile description text designed to test the system's ability to handle maximum field lengths and special characters like !@#$%^&*()_+-=[]{}|;':,.<>/?`~ and unicode characters like Ê∏¨Ë©¶, —Ç–µ—Å—Ç, ÿßÿÆÿ™ÿ®ÿßÿ±, ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£, „ÉÜ„Çπ„Éà. This description is intentionally long to approach typical URL length limits for encoding.\"\n        assert restored_profile_desc == expected_profile_desc, f\"Profile description mismatch after reload: {restored_profile_desc}\"\n        # Verify all app links are restored correctly\n        for i in range(8):\n            app_link_elem = frame.locator(f'xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[{i+1}]/div/input').nth(0)\n            restored_link = await app_link_elem.input_value()\n            expected_link = f\"https://example.com/app{i+1}?param=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&special=!@#$%^&*()_+-=[]{{}}|;':,.<>/?`~\"\n            assert restored_link == expected_link, f\"App link {i+1} mismatch after reload: {restored_link}\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095341283413//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.901Z",
    "modified": "2025-08-25T04:15:41.423Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "95f2dfcc-c7b4-4f15-b991-4a10ef486080",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC010-Responsive Layout - Adaptation on Various Screen Sizes",
    "description": "Verify the three-column layout (left input panel, right preview panel) adapts gracefully to desktop, tablet, and mobile screen sizes without breaking usability or visual quality.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Resize viewport to tablet size and verify layout adapts without overlapping elements and remains functional.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Resize viewport to tablet size and verify layout adapts without overlapping elements and remains functional.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Resize viewport to tablet size and verify layout adapts without overlapping elements and remains functional.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Resize viewport to tablet size and verify layout adapts without overlapping elements and remains functional.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Resize viewport to tablet size and verify layout adapts without overlapping elements and remains functional.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Name')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Category')\n        \n\n        # Resize viewport to tablet size and verify layout adapts without overlapping elements and remains functional.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The three-column layout on the application was successfully verified on desktop resolution. The left input panel and right preview panel are visible, appropriately sized, and functional without overlap or visual issues. However, due to repeated attempts to resize the viewport and lack of confirmation on layout adaptation, the tablet and mobile screen size verifications were not completed. Therefore, the task is only partially finished.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095176057212//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.907Z",
    "modified": "2025-08-25T04:12:56.185Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "1f9bd3e4-80ec-4b46-98a1-b45813bbd8b4",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC011-Demo Data Templates - Load and Apply Template Content",
    "description": "Verify users can select various predefined demo templates (AI, education, finance, news, productivity, health, tools) and that the form fields and live preview populate correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Add AI data' button to select the AI demo template.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Add Education data' button to select the Education demo template.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Add Finance data' button to select the Finance demo template.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Add News data' button to select the News demo template and verify form fields and live preview.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Add Productivity data' button to select the Productivity demo template.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Add Health data' button to select the Health demo template.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Add Tools data' button to select the Tools demo template and verify form fields and live preview.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Verify form fields and live preview for AI demo template\n        form_description = await frame.locator('xpath=//div[contains(text(),\"Profile\")]/following-sibling::div[contains(@class,\"description\")]').inner_text()\n        assert \"Some information about apps\" in form_description\n        apps_links = await frame.locator('xpath=//div[contains(text(),\"Apps Links\")]/following-sibling::div[contains(@class,\"apps\")]').all_inner_texts()\n        assert any(\"App 1\" in app for app in apps_links)\n        assert any(\"App 12\" in app for app in apps_links)\n        live_preview_labels = await frame.locator('xpath=//div[contains(text(),\"Links\")]/following-sibling::div[contains(@class,\"labels\")]').all_inner_texts()\n        assert \"Add AI data\" in live_preview_labels\n        # Verify form fields and live preview for Education demo template\n        form_description = await frame.locator('xpath=//div[contains(text(),\"Profile\")]/following-sibling::div[contains(@class,\"description\")]').inner_text()\n        assert \"Some information about apps\" in form_description\n        # Verify form fields and live preview for Finance demo template\n        form_description = await frame.locator('xpath=//div[contains(text(),\"Profile\")]/following-sibling::div[contains(@class,\"description\")]').inner_text()\n        assert \"Some information about apps\" in form_description\n        # Verify form fields and live preview for News demo template\n        form_description = await frame.locator('xpath=//div[contains(text(),\"Profile\")]/following-sibling::div[contains(@class,\"description\")]').inner_text()\n        assert \"Some information about apps\" in form_description\n        # Verify form fields and live preview for Productivity demo template\n        form_description = await frame.locator('xpath=//div[contains(text(),\"Profile\")]/following-sibling::div[contains(@class,\"description\")]').inner_text()\n        assert \"Some information about apps\" in form_description\n        # Verify form fields and live preview for Health demo template\n        form_description = await frame.locator('xpath=//div[contains(text(),\"Profile\")]/following-sibling::div[contains(@class,\"description\")]').inner_text()\n        assert \"Some information about apps\" in form_description\n        # Verify form fields and live preview for Tools demo template\n        form_category = await frame.locator('xpath=//div[contains(text(),\"Utilities\")]/following-sibling::div[contains(@class,\"category\")]').inner_text()\n        assert form_category == \"Tools\"\n        tools_apps = await frame.locator('xpath=//div[contains(text(),\"Utilities\")]/following-sibling::div[contains(@class,\"apps\")]//div[contains(@class,\"app-name\")]').all_inner_texts()\n        assert any(\"Natural Insight Calendar\" in app for app in tools_apps)\n        assert any(\"World Clock Master Time Zones\" in app for app in tools_apps)\n        assert any(\"Bobby Track Subscriptions\" in app for app in tools_apps)\n        assert any(\"Subscription Cancel\" in app for app in tools_apps)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095042912917//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.920Z",
    "modified": "2025-08-25T04:10:43.079Z"
  },
  {
    "projectId": "702c410c-1d6b-42ed-a3da-c5ce14f315b3",
    "testId": "2d8f433d-22fd-4b79-b8c2-fbf54e11ee63",
    "userId": "74087458-7081-7041-8d3d-a5fa7381353b",
    "title": "TC012-Form Components - Reusability and Consistency",
    "description": "Verify reusable form components function consistently across different forms and pages maintaining UI/UX standards and handling inputs correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Trigger validation messages by clearing required fields or entering invalid data, then verify messages and UI feedback\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Valid Name')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Valid Category')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-url')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://valid-url.com')\n        \n\n        # Navigate to social links form page to inspect reusable form components and test their UI consistency and input validations\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input text into valid input fields only, avoid buttons. Continue testing input validations and interactions on Education form inputs, including Label and URL fields at indexes 15 and 16.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Education Label')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://education-voicetube.com')\n        \n\n        # Navigate to social links form page to inspect reusable form components and test their UI consistency and input validations\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/main/div[2]/span/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Return to the main app page at localhost:3000 and navigate to the social links form again to continue testing reusable form components.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Navigate to social links form again by clicking the appropriate button to continue testing reusable form components\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Test input validations and interactions on the AI data form inputs\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Assistant')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AI')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('chatgpt')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('google-gemini')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('perplexity-ask-anything')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('grok')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kimi-Êô∫ËÉΩÂä©Êâã')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('microsoft-copilot')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('aido-ai-just-answer')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[8]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('spaced-repetition-braindeck')\n        \n\n        # Trigger explicit validation messages by submitting forms with invalid or empty inputs and verify messages and UI feedback\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[7]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[8]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # Assert that validation messages are displayed for empty required fields in profile form\n        validation_message_1 = await frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/div[contains(text(),\"required\")]').count()\n        assert validation_message_1 > 0, \"Validation message for required field in profile form is not displayed\"\n        # Assert that valid inputs do not show validation errors\n        validation_message_2 = await frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/div[contains(text(),\"required\")]').count()\n        assert validation_message_2 == 0, \"Validation message should not be displayed for valid inputs in profile form\"\n        # Assert that URL input validation works correctly in apps links form\n        invalid_url_error = await frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div[contains(text(),\"invalid\")]').count()\n        assert invalid_url_error > 0, \"Invalid URL error message is not displayed for invalid URL input\"\n        valid_url_error = await frame.locator('xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div/div[contains(text(),\"invalid\")]').count()\n        assert valid_url_error == 0, \"Invalid URL error message should not be displayed for valid URL input\"\n        # Assert that navigation to social links form page works and reusable components render consistently\n        button_social_links = frame.locator('xpath=html/body/div/div/div/div[2]/button[2]').nth(0)\n        assert await button_social_links.is_visible(), \"Social links form navigation button is not visible\"\n        # Assert that education form inputs accept valid data and show no validation errors\n        education_label_input = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div/input').nth(0)\n        education_url_input = frame.locator('xpath=html/body/div/div/div/div/div[5]/div[2]/div/div/div/div/div/div[2]/input').nth(0)\n        assert await education_label_input.input_value() == 'Education Label', \"Education label input value is incorrect\"\n        assert await education_url_input.input_value() == 'https://education-voicetube.com', \"Education URL input value is incorrect\"\n        # Assert that navigation back to main app page and social links form works\n        assert page.url == 'http://localhost:3000/', \"Page did not navigate back to main app page\"\n        button_social_links_main = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        assert await button_social_links_main.is_visible(), \"Social links form button on main page is not visible\"\n        # Assert that AI data form inputs accept valid data and show no validation errors\n        ai_name_input = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/input').nth(0)\n        ai_category_input = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div[2]/div/input').nth(0)\n        assert await ai_name_input.input_value() == 'Assistant', \"AI name input value is incorrect\"\n        assert await ai_category_input.input_value() == 'AI', \"AI category input value is incorrect\"\n        # Assert that all AI apps inputs have correct values as per extracted content\n        ai_apps_names = [\"chatgpt\", \"google-gemini\", \"perplexity-ask-anything\", \"grok\", \"kimi-Êô∫ËÉΩÂä©Êâã\", \"microsoft-copilot\", \"aido-ai-just-answer\", \"spaced-repetition-braindeck\"]\n        for i, app_name in enumerate(ai_apps_names):\n            input_locator = frame.locator(f'xpath=html/body/div/div/div/div/div[3]/div[2]/div/div/div[{i+1}]/div/input').nth(0)\n            input_value = await input_locator.input_value()\n            assert input_value.lower() == app_name.lower(), f\"AI app input value mismatch at index {i}: expected {app_name}, got {input_value}\"\n        # Assert that validation messages appear when submitting empty inputs in AI data form\n        empty_inputs_validation_count = await frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/div[contains(text(),\"required\")]').count()\n        assert empty_inputs_validation_count > 0, \"Validation messages for empty inputs in AI data form are not displayed\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74087458-7081-7041-8d3d-a5fa7381353b/1756095638712588//tmp/test_task/result.webm",
    "created": "2025-08-25T04:05:49.939Z",
    "modified": "2025-08-25T04:20:38.899Z"
  }
]
